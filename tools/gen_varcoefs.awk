#!/usr/bin/awk -f
# gen_varcoefs.awk
# Usage:
#   awk -f gen_varcoefs.awk var_coefs.key > var_coefs.h
#
# Input format (*.key):
#   g  w10  w20  wm11  w01  w11  w02   (g in [0..255], weights may be int or float)
#   Lines starting with '#' are comments.
#
#         curr  w10  w20
#   wm11  w01   w11
#         w02

BEGIN{
  FS="[ \t]+"
  nK = 0;
  name   = (NAME   != "" ? NAME   : "var_coefs")
  minDen = (MINDEN != "" ? MINDEN : 2999)
  maxDen = (MAXDEN != "" ? MAXDEN : 29999)
}

# Collect key rows
/^[ \t]*#/ {next}
NF>=5 {
  g = int($1)
  if (g < 0 || g > 255) { printf("tone %d out of range\n", g) > "/dev/stderr"; exit 1 }
  G[nK] = g + 0
  K10[nK]  = $2 + 0.0;
  K20[nK]  = $3 + 0.0;
  Km11[nK] = $4 + 0.0;
  K01[nK]  = $5 + 0.0;
  K11[nK]  = $6 + 0.0;
  K02[nK]  = $7 + 0.0;
  Krm[nK]  = $8 + 0.0;
  nK++
}

END {
  if (nK<2) {
    print "need >=2 key rows" > "/dev/stderr";
    exit 1;
  }

  # Sort keys by tone
  for (i = 0; i < nK; i++) {
    ord[i] = i;
  }
  for (i = 0; i < nK-1; i++) {
    for(j = i + 1; j < nK; j++) {
      if (G[ord[i]] > G[ord[j]]) {
        t = ord[i];
        ord[i] = ord[j];
        ord[j] = t;
      }
    }
  }

  # Interpolate 0..255 (linear) and normalize to sum=1
  for (g = 0; g <= 255; g++){
    # find bracketing keys
    L = ord[0];
    R = ord[nK - 1];
    for(ii = 0; ii < nK - 1; ii++){
      a = ord[ii];
      b = ord[ii + 1];
      if (G[a] <= g && g <= G[b]){
        L = a;
        R = b;
        break;
      }
      if (g<G[ord[0]]) {
        L = ord[0];
        R = ord[0];
        break;
      }
      if (g > G[ord[nK-1]]){
        L = ord[nK-1];
        R = ord[nK-1];
        break;
      }
    }
    GL = G[L];
    GR = G[R];
    t = (GR == GL) ? 0.0 : ((g - GL) / (GR - GL))

    w10 = K10[L] + (K10[R] - K10[L]) * t;
    w20 = K20[L] + (K20[R] - K20[L]) * t;
    wm1 = Km11[L] + (Km11[R] - Km11[L]) * t;
    w01 = K01[L] + (K01[R] - K01[L]) * t;
    w11 = K11[L] + (K11[R] - K11[L]) * t;
    w02 = K02[L] + (K02[R] - K02[L]) * t;
    wcr = Krm[L] + (Krm[R] - Krm[L]) * t;
    s = w10 + w20 + wm1 + w01 + w11 + w02;
    if (s <= 0) {
      w10 = K10[0];
      w20 = K20[0];
      wm1 = Km11[0];
      w01 = K01[0];
      w11 = K11[0];
      w02 = K02[0];
      wcr = Krm[0];
      s = w10 + w20 + wm1 + w01 + w11 + w02;
    }
    W10[g] = w10 / s;
    W20[g] = w20 / s;
    Wm1[g] = wm1 / s;
    W01[g] = w01 / s;
    W11[g] = w11 / s;
    W02[g] = w02 / s;
    Wcr[g] = wcr;
  }

  # Emit C typedef and table
  print "/* Auto-generated by gen_varcoefs.awk */"
  printf("static const int %s[][7] = {\n", name)

  for (g = 0; g <= 255; g++){
    bestErr = 1e15; besta = b = c = sum = 0
    # For each tone, search denominator den in [minDen..maxDen]
    # to best approximate (W10, W20, Wm11, W01, W11, W02)
    for (den = minDen; den <= maxDen; den++){
      cr = Wcr[g];
      a = int(0.5 + W10[g] * den * cr);
      b = int(0.5 + W20[g] * den * cr);
      c = int(0.5 + Wm1[g] * den * cr);
      d = int(0.5 + W01[g] * den * cr);
      e = int(0.5 + W11[g] * den * cr);
      f = int(den * cr) - a - b - c - d - e;
      if (f < 0) {
        # clamp and re-split if rounding overshoots
        d = 0;
      }
      err = (W10[g] - a / den) ^ 2 \
          + (W20[g] - b / den) ^ 2 \
          + (Wm1[g] - c / den) ^ 2 \
          + (W01[g] - d / den) ^ 2 \
          + (W11[g] - e / den) ^ 2 \
          + (W02[g] - f / den) ^ 2 \
          ;
      if (err < bestErr){
        bestErr = err;
        besta = a;
        bestb = b;
        bestc = c;
        bestd = d;
        beste = e;
        bestf = f;
        sum = den;
      }
      # early exit when very close (optional)
      if (bestErr < 1e-15 && den > 64) {
        break
      }
    }
    printf("   { %9d, %9d, %9d, %9d, %9d, %9d, %10d },     /* %4d */\n", \
           besta, bestb, bestc, bestd, beste, bestf, sum, g)
  }
  print "};"
}

